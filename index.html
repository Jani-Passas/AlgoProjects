<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pathfinding Maze Solver</title>
    <style>
        .grid {
            display: grid;
            grid-template-columns: repeat(5, 40px);
            gap: 2px;
        }
        .cell {
            width: 40px;
            height: 40px;
            border: 1px solid #333;
            text-align: center;
            line-height: 40px;
            cursor: pointer;
        }
        .blocked {
            background-color: #000;
        }
        .path {
            background-color: #28a745;
        }
    </style>
</head>
<body>
    <h1>Pathfinding Maze Solver</h1>
    <div id="grid" class="grid"></div>
    <button id="solveBtn">Find Shortest Path</button>
    <pre id="output"></pre>

    <script>
        const gridHeight = 4;
        const gridWidth = 5;
        const grid = document.getElementById('grid');
        let maze = [
            [1, 0, 2, 3, 1],
            [2, 3, 1, 0, 2],
            [0, 2, 6, 4, 3],
            [1, 7, 2, 0, 1]
        ];

        function createGrid() {
            grid.innerHTML = '';
            for (let i = 0; i < gridHeight; i++) {
                for (let j = 0; j < gridWidth; j++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.textContent = maze[i][j];
                    cell.addEventListener('click', () => toggleCell(cell));
                    grid.appendChild(cell);
                }
            }
        }

        function toggleCell(cell) {
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            if (maze[row][col] !== 0) {
                maze[row][col] = 0;
                cell.classList.add('blocked');
            } else {
                maze[row][col] = 1;
                cell.classList.remove('blocked');
            }
        }

        document.getElementById('solveBtn').addEventListener('click', async () => {
            document.querySelectorAll('.cell').forEach(cell => cell.classList.remove('path'));
            try {
                const wasmInstance = await loadWasm();
                displayPath([[0, 0], [0, 2], [1, 2], [2, 2], [3, 2]]); // Mock path
            } catch (error) {
                document.getElementById('output').innerText = `Error: ${error.message}`;
            }
        });

        function displayPath(path) {
            path.forEach(([row, col]) => {
                const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
                if (cell) cell.classList.add('path');
            });
            document.getElementById('output').innerText = 'Path displayed!';
        }

        async function loadWasm() {
            const response = await fetch('robot_navigation.wasm');
            const bytes = await response.arrayBuffer();
            const results = await WebAssembly.instantiate(bytes, {
                env: {
                    memory: new WebAssembly.Memory({ initial: 256 }),
                }
            });
            return results.instance;
        }

        createGrid();
    </script>
</body>
</html>
